// MongoStatement.java

/**
 *      Copyright (C) 2008 10gen Inc.
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 */

package com.mongodb.jdbc;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;

import com.mongodb.DBCursor;

public class MongoStatement implements Statement {

	MongoConnection _conn;

	final int _type;
	final int _concurrency;
	final int _holdability;

	int _fetchSize = 0;
	int _maxRows = 0;

	MongoResultSet _last;
	ResultSet _keys = new EmptyResultSet(null);

	private int intResult = 0;

	MongoStatement(MongoConnection conn, int type, int concurrency,
			int holdability) {
		_conn = conn;
		_type = type;
		_concurrency = concurrency;
		_holdability = holdability;

		if (_type != 0)
			throw new MongoUnsupportedOperationException("type not supported yet");
		if (_concurrency != 0)
			throw new MongoUnsupportedOperationException(
					"concurrency not supported yet");
		if (_holdability != 0)
			throw new MongoUnsupportedOperationException(
					"holdability not supported yet");

	}

	// --- batch ---

	public void addBatch(String sql) {
		throw new MongoUnsupportedOperationException("batch not supported");
	}

	public void clearBatch() {
		throw new MongoUnsupportedOperationException("batch not supported");
	}

	public int[] executeBatch() {
		throw new MongoUnsupportedOperationException("batch not supported");
	}

	// --- random

	public void cancel() {
		throw new MongoRuntimeException("not supported yet - can be");
	}

	public void close() {
		_conn = null;
	}

	public Connection getConnection() {
		return _conn;
	}

	public boolean isClosed() {
		return _conn == null;
	}

	public boolean isPoolable() {
		return true;
	}

	public void setPoolable(boolean poolable) {
		if (!poolable)
			throw new MongoRuntimeException(
					"why don't you want me to be poolable?");
	}

	public void clearWarnings() {
		_conn.clearWarnings();
	}

	// --- writes ----

	public boolean execute(String sql) throws SQLException {
		Executor executor = new Executor(_conn, _conn.getDb(), sql);
		if (executor.isQuery()) {
			DBCursor cursor = executor.query();
			if (_fetchSize > 0) {
				cursor.batchSize(_fetchSize);
			}
			if (_maxRows > 0) {
				cursor.limit(_maxRows);
			}
			_last = new MongoResultSet(_conn.getDb(), cursor, executor.getMetaData());
			return true;
		}
		intResult  = executor.writeop();
		if (executor.getKeys() != null) {
			_keys = executor.getKeys();
		}
		// TODO finish write
		return false;
		// throw new MongoRuntimeException("execute not done");
	}

	public boolean execute(String sql, int autoGeneratedKeys) {
		throw new MongoRuntimeException("execute not done");
	}

	public boolean execute(String sql, int[] columnIndexes) {
		throw new MongoRuntimeException("execute not done");
	}

	public boolean execute(String sql, String[] columnNames) {
		throw new MongoRuntimeException("execute not done");
	}

	public int executeUpdate(String sql) throws SQLException {
		return new Executor(_conn, _conn.getDb(), sql).writeop();
	}

	public int executeUpdate(String sql, int autoGeneratedKeys) {
		throw new MongoRuntimeException("executeUpdate not done");
	}

	public int executeUpdate(String sql, int[] columnIndexes) {
		throw new MongoRuntimeException("executeUpdate not done");
	}

	public int executeUpdate(String sql, String[] columnNames) {
		throw new MongoRuntimeException("executeUpdate not done");
	}

	public int getUpdateCount() {
		//throw new MongoRuntimeException("getUpdateCount not done");
		return intResult;
	}

	public ResultSet getGeneratedKeys() {
		return _keys;
		// throw new MongoRuntimeException("getGeneratedKeys notn done");
	}

	// ---- reads -----

	public ResultSet executeQuery(String sql) throws SQLException {
		// TODO
		// handle max rows
		Executor exec = new Executor(_conn, _conn.getDb(), sql);
		DBCursor cursor = exec.query();
		if (_fetchSize > 0)
			cursor.batchSize(_fetchSize);
		if (_maxRows > 0)
			cursor.limit(_maxRows);

		_last = new MongoResultSet(_conn.getDb(), cursor, exec.getMetaData());
		return _last;
	}

	public int getQueryTimeout() {
		throw new MongoRuntimeException("query timeout not done");
	}

	public void setQueryTimeout(int seconds) {
		throw new MongoRuntimeException("query timeout not done");
	}

	// ---- fetch modifiers ----

	public int getFetchSize() {
		return _fetchSize;
	}

	public void setFetchSize(int rows) {
		_fetchSize = rows;
	}

	public int getMaxRows() {
		return _maxRows;
	}

	public void setMaxRows(int max) {
		_maxRows = max;
	}

	public int getFetchDirection() {
		throw new MongoRuntimeException("fetch direction not done yet");
	}

	public void setFetchDirection(int direction) {
		throw new MongoRuntimeException("fetch direction not done yet");
	}

	public int getMaxFieldSize() {
		throw new MongoRuntimeException("max field size not supported");
	}

	public void setMaxFieldSize(int max) {
		throw new MongoRuntimeException("max field size not supported");
	}

	public boolean getMoreResults() {
		throw new MongoRuntimeException("getMoreResults not supported");
	}

	public boolean getMoreResults(int current) {
		throw new MongoRuntimeException("getMoreResults not supported");
	}

	public ResultSet getResultSet() {
		return _last;
	}

	// ---- more random -----

	public SQLWarning getWarnings() {
		//TODO this._conn.getWarnings();
		return null;
	}

	public void setCursorName(String name) {
		throw new MongoUnsupportedOperationException("can't set cursor name");
	}

	public void setEscapeProcessing(boolean enable) {
		if (!enable)
			throw new MongoRuntimeException(
					"why do you want to turn escape processing off?");
	}

	public int getResultSetConcurrency() {
		return _concurrency;
	}

	public int getResultSetHoldability() {
		return _holdability;
	}

	public int getResultSetType() {
		return _type;
	}

	public <T> T unwrap(Class<T> iface) throws SQLException {
		throw new MongoUnsupportedOperationException();
	}

	public boolean isWrapperFor(Class<?> iface) throws SQLException {
		throw new MongoUnsupportedOperationException();
	}

}
